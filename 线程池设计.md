# 线程池设计

本项目使用线程池 + Reactor模式并发处理用户请求，主线程负责监听IO事件的发生，一旦socket可以读写，则通知工作线程（线程池中的线程）负责处理读写+逻辑（HTTP请求报文的解析等等）。这就是Reactor模式所做的，主线程（I/O处理单元）仅仅负责监听文件描述符上是否有事件发生即（可读、可写）事件，若有事件发生，则立即通知工作线程（逻辑单元），将socket可读可写事件放入请求队列，交给工作线程处理。

所以线程池主要做两件事情：

1.   处理读写（`write()`和`read()`函数）。
2.   处理HTTP请求报文，包括解析HTTP请求报文和响应HTTP请求。

## 任务对象是如何插入到线程池中的

在eventLoop()函数的逻辑中，通过epoll_wait()阻塞监听文件描述符上的事件，如果有事件发生并且事件发生在listenfd的话，则调用dealWithClientData()函数，将`listenfd`上到达的`connection`通过 `accept()`接收，并返回一个新的socket文件描述符`connfd`用于和用户通信，并对用户请求返回响应，同时将这个`connfd`注册到内核事件表中，等用户发来请求报文，如下代码：

```c++
    // 将cfd加入到红黑树上
    addfd(m_epollfd, cfd, true);

    // 为该次连接（用户）初始化
    users[cfd].init(cfd, address);
```



同时，在上述的逻辑中，如果epoll_wait()阻塞监听文件描述符上的事件为读事件（EPOLLIN）或者写事件（EPOLLOUT），那么主线程就会调用读和写事件的处理函数：

```c++
            // 如果是读事件
            else if (events[i].events & EPOLLIN)
            {
                dealWithRead(sockfd);
            }
            // 如果是写事件
            else if (events[i].events & EPOLLOUT)
            {
                dealWithWrite(sockfd);
            }
```

这两个函数所做的事情也很简单，仅仅是将该任务对象（users）插入到线程池的任务队列中：

```c++
void webserver::dealWithRead(int sockfd) /* 处理读事件 */
{
    // reactor模式
    // 将socket可读事件放入请求队列，交给工作线程处理，0代表读事件
    m_pool->append(users + sockfd, 0);
}
/* 写事件同理 */
```

## 线程池主要结构

-   所谓线程池，就是一个`pthread_t`类型的普通数组，通过`pthread_create()`函数创建`m_thread_number`个**线程**，用来执行`worker()`函数以执行每个请求处理函数（HTTP请求的`process`函数），通过`pthread_detach()`将线程设置成脱离态（detached）后，当这一线程运行结束时，它的资源会被系统自动回收，而不再需要在其它线程中对其进行 `pthread_join()` 操作。
-   操作工作队列一定要加锁（`locker`），因为它被所有线程共享。
-   我们用信号量来标识请求队列中的请求数，通过`m_queuestat.wait();`来等待一个请求队列中待处理的HTTP请求，然后交给线程池中的空闲线程来处理。

## 为什么要使用线程池？

当你需要限制你应用程序中同时运行的线程数时，线程池非常有用。因为启动一个新线程会带来性能开销，每个线程也会为其堆栈分配一些内存等。为了任务的并发执行，我们可以将这些任务任务传递到线程池，而不是为每个任务动态开启一个新的线程。